# Homework 3 Q/A

## Объясните смысл и напишите формулы для следующих метрик производительности процессора IPC, CPI, Performance, Dynamic Power

**I**nstruction **P**er **C**ycle: **IPC** = число исполненных инструкций / число затраченных на исполнение циклов.
Скорость утилизации инструкций в квантах процессорного времени.

**CPI** = $\frac{1}{IPC}$

**Performance** = $\frac{1}{Time}$ = $\frac{1}{N_{inst} \cdot CPI \cdot T_{cycle}} = \frac{1}{N_{inst}}\cdot IPC \cdot f$  
Формула производительсности задает три способа оптимизации: алгоритмический - уменьшает $N$ архитектурный - увеличивает IPC, на уровне электроники - увеличивает частоту

**Dynamic power** = $CV^2f$, где V - напряжение, f - частота, C - динамическая емкость процессора.

## Что такое суперскалярный (superscalar) процессор?

Процессор поддерживающий параллелизм на уровне инструкций, IPC > 1 (e.g. pipeline)

## Какие типы зависимостей по данным существуют? Приведите примеры аппаратных оптимизаций, которые позволяют сократить связанные задержки или разрешить каждый тип зависимостей.

* Read after write - data dependency. Чтение происходит раньше, чем запись результата предыдущей инструкции.
```
v1 = v2 + v3
v4 = v1 + v5
```
Оптимизация forwarding позволяет передать зависимое значение напрямую из стадии writeback инструкции producer-а в стадию execute инструкции consumer-а.

* Write after read - anti-dependency. Запись в регистр из которого происходит чтение.
```
v1 = v2 + v3
v2 = v4 + v5
```
Оптимизация register renaming - спекулятивное состояние CPU оперирует большим числом регистров, чем программное. Это позволяет присваивать одному архитектурному регистру разные физические регистры, избегая WAR.

* Write after write - порядок записи в регистр должен быть сохранен, чтобы в итоге там не оказалось v2 + v3.
```
v1 = v2 + v3
v1 = v4 + v5
```
Оптимизация register renaming решает и эту проблему.

## С какой целью инструкцию Store разделяют на микро-операции STA (Store address calculation) и STD (Store data calculation) ?
Чтобы исполнить Load OOO нужно проверить наличие пересечений с Store инструкциями в ROB. Адрес Store вычисляется только после исполнения Store, которое происходит когда Store дождался готовности своего адреса, данных и порядка исполнения. Для проверки Load инструкции готовности данных Store не требуется. Чтобы устранить ложную зависимость от данных инструкция Store разбивается на генерацию адреса и данных.

## Объясните назначение и функции следующих аппаратных структур: ROB, Scheduler Queue (Issue Queue, Reservation Station), RAT, PRF, Load Buffer, Store Buffer

### Reorder Buffer (ROB)
Окно параллельно исполняемых инструкций в OOO процессоре. Обеспечивает видимость in-order при OOO исполнении.

### Scheduler Queue
Для выбора в ROB инструкций готовых к исполнению (на каждый такт) или для анализа зависимостей при добавлении инструкции в ROB нужно сделать поиск по всем инструкциям. Для того чтобы уменьшить число проверок используется Scheduler queue - очередь из неисполненных инструкций (20-30% от всех в ROB). Проверяются только инструкции в этой очереди.

### Register aliases table
Нужна для register renaming. Сопоставляет архитектурные регистры с физическими.

### Physical Register File
Хранит значения физических регистров

### Store buffer and Load Buffer
Load перед исполнением должен проверить, что предыдущие Store в ROB не имеют пересечений по адресу. Для ускорения и упрощения проверки все Store помещаются в Store Buffer, а Load в Load Buffer. Все проверки адресов выполняются на этих двух буферах, в том числе для Store forwarding.
Суммарно LB и SB отвечают за
1. Блокировку Load зависимых от Store
2. store forwarding
3. Проверку корректности спекулятивного исполнения load
## Пусть каждая 5ая инструкция в процессоре это Branch. Предсказатель переходов имеет точность 90%. Оцените, ROB какого максимального размера имеет смысл для такого процессора.
Пусть ROB имеет размер L, тогда вероятность того, что последняя попавшая в него инструкция исполнится:  
$p = 0.9^{L / 5}$.  
 Для ROB длиной 100 инструкций вероятность приблизительно 12%, для 30 инструкций приблизительно 53%.

## Что такое Memory Disambiguation?
Memory disambiguation это механизм проверки зависимостей по данным, проходящих через обращения в память.

## В чем заключается проблема со спекулятивным исполнением Store инструкций?
Слишком дорогая и сложная процедура отката состояния в случае ошибки.

## Что такое Store forwarding и Load speculation в OOO процессоре?
Store forwarding - оптимизация, позволяющая load инструкции, зависящей от store, получить значение напрямую из инструкции store, минуя память.
```
st x1, [0x100]
ld x2, [0x100] // вместо еще одного обращения в память x2 <- x1
```
Load speculation - оптимизация, в которой load инструкция не дожидается всех предыдущих STA, а исполняется спекулятивно, с последующей проверкой, когда все STA готовы.

## Что такое Simultaneous Multithreading?
Технология одновременного исполнения нескольких потоков на одном ядре за счет копирования некоторых блоков ядра.